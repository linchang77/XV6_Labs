# Lab01: xv6 and Unix utilities

## 1.sleep (easy)

### 1）实验目的

Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.

### 2）实验步骤

1. 在user中创建sleep.c文件
2. 调用内部的sleep函数，完成代码编写
3. 运行```make GRADEFLAGS=sleep grade```测试代码正确性

### 3）实验中遇到的困难和解决办法

1. 命令行参数处理：在处理命令行参数时，我遇到了如何优雅地处理错误输入的问题。通过参考示例代码，我学习了如何进行基本的错误检查和处理。
2. 系统调用的理解和使用：虽然 sleep 系统调用本身并不复杂，但理解它在内核中的实现和如何从用户程序中调用它，仍然需要一些时间和努力。

### 4）实验心得

通过这个实验，我不仅学会了在 xv6 中编写一个简单的用户程序，还加深了对系统调用机制的理解。这次实验为我后续深入学习和开发操作系统内核奠定了良好的基础。

## 2.pingpong (easy)

### 1）实验目的

Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print "<pid>": received ping", where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print "<pid>: received pong", and exit. Your solution should be in the file user/pingpong.c.

### 2）实验步骤

1. 创建管道：使用 pipe 系统调用创建两个管道，一个用于父进程向子进程发送数据，另一个用于子进程向父进程发送数据。
2. 创建子进程：使用 fork 系统调用创建一个子进程。
3. 进程间通信：
    - 父进程向第一个管道写入一个字节。
    - 子进程从第一个管道读取该字节，打印消息并通过第二个管道将字节写回父进程。
    - 父进程从第二个管道读取字节并打印消息。
4. 添加到 Makefile：将 pingpong 程序添加到 UPROGS 中，以便编译并运行。

### 3）实验中遇到的困难和解决办法

1. 管道创建失败
   - 困难描述： 在使用 pipe 系统调用创建管道时，有时会出现管道创建失败的情况。
   - 解决办法： 检查 pipe 系统调用的返回值，如果返回 -1，则说明管道创建失败。此时应该打印错误消息并退出程序。
2. 管道通信失败
   - 困难描述： 在使用 read 和 write 系统调用进行管道通信时，有时会出现通信失败的情况。
   - 解决办法： 检查 read 和 write 系统调用的返回值，如果返回值不等于预期的字节数，则说明通信失败。此时应该打印错误消息并退出程序。

### 4）实验心得

在这次实验中，我实现了一个简单的 "乒乓" 程序，通过两个进程间的管道通信，体验了一次实践操作系统基础概念的过程。这次实验不仅巩固了我对系统调用和进程间通信的理解，还让我在实际操作中加深了对 xv6 操作系统的认识。

## 3.primes (moderate)/(hard)

### 1）实验目的

Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c.

### 2）实验步骤

1. **创建主进程**：
   - 主进程负责创建第一个管道，并将 2 到 35 的数字写入管道。

2. **创建筛选进程**：
   - 为每个质数创建一个筛选进程，筛选进程从左邻居的管道中读取数字，并将不是其自身质数倍数的数字写入右邻居的管道。
   - 使用 `pipe` 创建新的管道，并使用 `fork` 创建新的进程。

3. **关闭不需要的文件描述符**：
   - 为了避免文件描述符和进程资源耗尽，必须在每个进程中关闭不需要的管道端。

4. **等待所有进程结束**：
   - 主进程在达到 35 后，等待所有子进程、孙进程等结束，确保所有输出打印完毕后才退出。

### 3）实验中遇到的困难和解决办法

1. **文件描述符资源耗尽**：
   - **困难描述**：在创建多个管道和进程时，如果不正确关闭不需要的文件描述符，会导致文件描述符资源耗尽，程序崩溃。
   - **解决办法**：在每个进程中，确保只保留必要的管道端，其余管道端在合适的时机关闭。具体做法如下：
  
     ```c
     close(p[0]); // 关闭不需要的读端
     close(p[1]); // 关闭不需要的写端
     ```

2. **进程同步问题**：
   - **困难描述**：主进程需要等待所有子进程、孙进程等结束，否则主进程可能会过早退出。
   - **解决办法**：在主进程中使用 `wait` 系统调用等待所有子进程结束，确保在所有输出打印完毕后才退出主进程。

3. **正确处理管道读写操作**：
   - **困难描述**：在管道中传输数据时，需要确保读写操作正确无误，否则会导致数据传输错误。
   - **解决办法**：使用 `read` 和 `write` 系统调用时，确保每次操作读写的是 32 位整数，避免使用格式化的 ASCII 输入输出。

### 4）实验心得

通过这次实验，我深入理解了使用管道和进程进行进程间通信的基本方法，并掌握了如何在 xv6 操作系统中实现并发程序。实验中遇到的困难让我更加熟悉了 UNIX 系统调用的使用方法和调试技巧。这次实验不仅巩固了我对操作系统课程理论知识的理解，也为我今后在实际项目中应用这些知识打下了坚实的基础。

## find (moderate)

### 1）实验目的

编写一个简单版本的 UNIX `find` 程序：在目录树中查找具有特定名称的所有文件。要求通过递归遍历目录，并忽略 `.` 和 `..` 目录。

### 2）实验步骤

1. **实现基本文件读取**：
   - 查看 `user/ls.c`，了解如何读取目录中的文件。
   - 使用 `opendir` 和 `readdir` 函数读取目录内容。

2. **实现字符串比较**：
   - 使用 `strcmp` 函数比较文件名，判断是否与目标文件名匹配。

3. **实现递归遍历目录**：
   - 在读取目录内容时，如果遇到子目录，递归调用 `find` 函数进入子目录。
   - 确保忽略 `.` 和 `..` 目录，防止无限递归。

4. **添加错误处理**：
   - 如果用户没有传入参数，打印错误信息。
   - 如果打开目录失败，打印错误信息。

5. **将程序添加到 Makefile 中**：
   - 将 `find` 程序添加到 `UPROGS` 变量中，以便在编译时包含该程序。

6. **编译并运行**：
   - 使用 `make qemu` 编译并运行 xv6。
   - 在 xv6 shell 中运行 `find . filename` 测试程序。

### 3）实验中遇到的困难和解决办法

1. **目录读取错误**：
   - **困难描述**：在读取目录时，有时会遇到权限问题或目录不存在的问题，导致程序崩溃。
   - **解决办法**：在打开目录时添加错误处理，检查 `opendir` 返回值，如果为 NULL，打印错误信息并返回。

     ```c
     DIR *dp = opendir(path);
     if (dp == NULL) {
         fprintf(2, "find: cannot open %s\n", path);
         return;
     }
     ```

2. **递归调用过深**：
   - **困难描述**：如果目录结构过深，递归调用可能会导致栈溢出。
   - **解决办法**：优化递归函数，确保在每次递归调用前正确释放资源，并使用尾递归优化。

3. **字符串处理错误**：
   - **困难描述**：由于 C 语言字符串处理相对复杂，容易出现内存泄漏或字符串比较错误。
   - **解决办法**：在字符串操作时，确保使用安全函数如 `strncpy`，并检查所有返回值避免越界访问。

4. **文件描述符资源耗尽**：
   - **困难描述**：如果程序在递归遍历目录时不正确关闭文件描述符，会导致文件描述符资源耗尽。
   - **解决办法**：在每次打开目录读取完成后，确保关闭文件描述符以释放资源。

     ```c
     closedir(dp);
     ```

### 4）实验心得

通过这次实验，我深入理解了 UNIX 操作系统中目录遍历和文件查找的基本方法，并掌握了递归编程的技巧。实验中遇到的各种困难让我更加熟悉了 C 语言的字符串处理和错误处理方法。这次实验不仅巩固了我对操作系统课程的理论知识，也为我今后在实际项目中应用这些知识打下了坚实的基础。

## xargs (moderate)

### 1）实验目的

编写一个简单版本的 UNIX `xargs` 程序：从标准输入读取每一行，并为每一行运行一个命令，将该行作为参数传递给命令。目标是理解如何使用 `fork` 和 `exec` 创建和执行子进程，并掌握如何从标准输入读取数据。

### 2）实验步骤

1. **读取输入行**：
   - 从标准输入逐字符读取，直到遇到换行符 (`'\n'`)，将读取的字符存储为一行。

2. **分割命令和参数**：
   - 使用 `strtok` 或其他字符串分割方法，将输入行分割成命令和参数。

3. **创建子进程**：
   - 使用 `fork` 创建子进程。
   - 在子进程中使用 `exec` 执行命令，将读取的行作为参数传递给命令。

4. **等待子进程结束**：
   - 在父进程中使用 `wait` 等待子进程完成。

5. **添加程序到 Makefile 中**：
   - 将 `xargs` 程序添加到 `UPROGS` 变量中，以便在编译时包含该程序。

6. **编译并运行**：
   - 使用 `make qemu` 编译并运行 xv6。
   - 在 xv6 shell 中运行 `xargs` 程序进行测试。

### 3）实验中遇到的困难和解决办法

1. **输入行的读取和处理**：
   - **困难描述**：逐字符读取标准输入直到换行符时，需要正确处理缓冲区和字符串末尾。
   - **解决办法**：使用一个字符数组存储读取的字符，遇到换行符时添加字符串结束符 (`'\0'`)，确保每次读取到的都是一个完整的字符串。

     ```c
     char buf[MAXLINE];
     int i = 0;
     while (read(0, &c, 1) == 1) {
         if (c == '\n') {
             buf[i] = '\0';
             // Process the line
             i = 0;
         } else {
             buf[i++] = c;
         }
     }
     ```

2. **命令和参数的分割**：
   - **困难描述**：如何将输入行分割成命令和参数，并传递给 `exec` 函数。
   - **解决办法**：使用 `strtok` 函数分割字符串，将命令和参数存储到一个字符指针数组中。

     ```c
     char *argv[MAXARG];
     int argc = 0;
     char *token = strtok(buf, " ");
     while (token != NULL && argc < MAXARG) {
         argv[argc++] = token;
         token = strtok(NULL, " ");
     }
     argv[argc] = NULL;
     ```

3. **子进程的创建和执行**：
   - **困难描述**：在子进程中执行命令，并正确处理错误。
   - **解决办法**：使用 `fork` 创建子进程，在子进程中使用 `exec` 执行命令，并在父进程中使用 `wait` 等待子进程结束。

     ```c
     if (fork() == 0) {
         exec(argv[0], argv);
         fprintf(2, "exec %s failed\n", argv[0]);
         exit(1);
     } else {
         wait(0);
     }
     ```

4. **文件描述符和资源管理**：
   - **困难描述**：确保在每个子进程中正确关闭文件描述符，避免资源泄漏。
   - **解决办法**：在子进程结束后，使用 `wait` 确保资源被正确释放。

### 4）实验心得

通过这次实验，我深入理解了 UNIX 系统调用的基本方法，特别是如何使用 `fork` 和 `exec` 创建和执行子进程，并掌握了如何从标准输入读取数据并处理字符串。实验中遇到的各种困难让我更加熟悉了 C 语言的字符串处理和错误处理方法。在解决问题的过程中，我学会了如何通过调试和优化代码，提高程序的健壮性和效率。这次实验不仅巩固了我对操作系统课程的理论知识，也为我今后在实际项目中应用这些知识打下了坚实的基础。